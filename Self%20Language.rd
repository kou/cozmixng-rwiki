= Self Language

== オブジェクトとスロット

Selfでは，オブジェクトはスロットから作成されます．スロットは
名前を持ち，オブジェクトへの参照を含んでいます．Selfでは，オ
ブジェクトの状態と振る舞いの全てはそのオブジェクトのスロット
に含まれています．

メッセージがオブジェクトに送られたとき，メッセージ（セレクタ）
の名前は同じ名前のスロットに対してマッチされます．これが，メッ
セージ検索と呼ばれているプロセスです．メッセージ検索の詳細に
ついては後述します．

メッセージへのレスポンスにおいて起こることは，そのメッセージ
にマッチしたスロットの内容によって決まります．スロットはメソッ
ドスロットかデータスロットになります．

もし，スロットにメソッド（実行可能なコードを含んでいるオブジェ
クト）が入っていればメソッドスロットになります．メッセージの
レスポンスでは，メソッドが実行され，その結果が返されます．

メソッド以外のオブジェクトへの参照が入っているスロットはデー
タスロットです．もし，メッセージがデータスロットにマッチした
場合は，そのデータスロットの内容が返されます．

データスロットは定数，あるいは代入可能なものです．定数データ
スロット(({foo}))は，(({foo}))メッセージに対してはスロットの
値を返します．代入可能なデータスロット(({bar}))は，(({bar}))
メッセージに対してはスロットの値を返し，(({bar: v}))メッセー
ジに対してはスロットの内容を(({v}))と置き換えます．

=== スロットの例

図は銀行口座オブジェクトを示しています．このオブジェクトは
(({balance}))（残高），(({deposit:}))（預金），(({withdraw:}))
（引き出す）という名前の3 つのスロットを持っています．
(({balance}))は代入可能なスロットで現在100が入っています．一
方，(({deposit:}))と(({withdraw:}))はメソッドが入っています．
(({deposit:}))は引数を受け取り，それに残高を加えます．
(({withdraw:}))は残高から引数を引きますが，残高は0より小さく
なりません．

このオブジェクトのグラフィカルな表示では，スロットの右側のボ
タンのアイコンによってスロットの種類を見分けることができます．

  * メソッドスロットのアイコンはテキストエディタを意味します．
    アイコンを左クリックすると，エディタでメソッドのソースを
    開きます．

  * 定数スロットのアイコンは等号の記号で，不変であることを意
    味します．

  * 代入可能なデータスロットのアイコンはコロンです．これは，
    代入メッセージはスロット名の最後にコロンがついたものであ
    るということを思い出すためです．

  * データスロットのボタン上で左クリックをすると，そのスロッ
    トから参照されているオブジェクトが呼び出されます．

もし，画面からオブジェクトを消したい場合は，右クリックをする
と出てくる（青いメニューの中にある）`Dismiss'という項目を使い
ます（???）．

各ボタンの左にある（イタリック体でかかれた）テキストはスロット
の中に何があるかを説明します．完全な説明には場所が足りないと
きがあるので，そのときは省略記号（...）が現れます．ボタンを左
クリックすると，メソッドエディタやオブジェクトが呼び出されて
全ての情報を見ることができます．

オブジェクトのスロットは，左上の三角をクリックすることによっ
て隠したり，出したりすることができます．つまり，展開されてい
るときは折り畳み，折り畳まれているときは展開されます．

== メッセージとメソッド

Selfでは，全ての計算はメッセージによって初期化されます．メッ
セージはアトミックなアクションとして結果を出したり，実行され
るメソッドを引き出すことができます（アトミックなアクションと
いうのは，例えば，データスロットの値を取り出す，代入可能スロッ
トに値を代入するといったアクションです）．同様に，メソッドは
さらにメッセージを送るかもしれません．

評価器をつかって口座にメッセージを送ろうとすることができます．
オブジェクトの評価器を得るには，オブジェクトのタイトルバーで
真ん中ボタンを押すと出てくる（黄色い）メニューを使います（???）．
評価器の中に入力した式は，評価ボタンをクリックするとオブジェ
クトの文脈で評価されます．オブジェクトの文脈とは，例えば，
(({self}))がオブジェクト自身に束縛されているということです．

例をあげます．

: balance
   現在の残高を返します．

: deposit: n
   残高を((|n|))増やします．

: withdraw: n
   残高を((|n|))減らします．下限は0です．

評価には必ず結果のオブジェクトがあります．(({deposit:}))と
(({withdraw:}))メッセージの結果は銀行口座オブジェクト自身で
す．もし，結果が多くの評価（多くの評価レシーバ自身を返す？？？） 
と異なれば，結果はカーソルにくっついています．カーソルを手と
呼び，オブジェクトは手の中にあるということがあります．右ボタ
ンをクリックすることによって，手の中にあるオブジェクトを落と
す（ドロップする）ことができます．もし，評価の結果がレシーバオ
ブジェクトの場合は，手にくっつかずに，カーソルがわずかに震え
ます．

もし，評価の結果に興味がなければ，評価器で真ん中ボタンを押す
と出てくるメニューにある`Do selection'を使えます（???）．これ
は，選択した式を評価しますが，結果は無視されます．

=== メソッド起動の例

  deposit: 50 and withdraw: 20

銀行口座に(({deposit: 50}))を送ることによって，
(({deposit:}))という名前のスロットを検索します．これは，同じ
名前のメソッドを見付けます．メソッドの実行は，仮引数(({d}))
を実引数(({50}))に束縛し，銀行口座オブジェクトを(({self}))に
束縛することから始まります．

(({deposit:}))メソッドは以下のように読めます（Selfの構文と意
味の詳細は後ほど説明します）．

  * (({balance}))メッセージを(({self}))（つまり
    (({counter}))）に送り，(({balance}))スロットの値を取得し
    ます．メッセージが(({self}))に送られたとき，（Smalltalkと
    違って）明示的にレシーバを述べる必要がないことに注意して
    ください．

  * 引数dの値（50）を取得します．

  * (({balance}))の結果に引数として(({d}))の結果をつけて
    (({+}))メッセージを送ります．これは(({balance}))の結果と
    (({d}))の結果の和を返します．

  * (({self}))に(({balance:}))メッセージを送り，引数として
    (({balance + d}))の結果を渡します．これは，(({balance}))
    に新しい値を代入します．代入の結果は(({self}))（つまり銀
    行口座オブジェクト）で，代入された値ではありません．

もし，(({deposit:}))をもっと明示的に書くと以下のようになりま
す．

  self balance: ((self balance) + d)

最後の(({balance:}))メッセージを送る前を除けば，(({withdraw:
20}))メッセージを送ることも似ています．(({balance:}))メッセー
ジを送る前は，(({balance - w}))の結果が(({0}))に送られる
(({max:}))メッセージの引数として渡されています．ここでは，メッ
セージのレシーバが明示的に書かれています．(({max:}))メッセー
ジは別の数を引数としてある数に送られ，与えられた数のうち大き
い数を返します．

(({self}))へのメッセージを明示的に括弧で囲んで書いた
(({withdraw:}))は以下のようになります．

  self balance: (0 max: ((self balance) - w))

=== デバッガ

Selfデバッガを使って，メソッドの実行を一つずつ見ていくことが
できます．デバッガを起動するには，(({halt}))メッセージがわか
るオブジェクトに(({halt}))メッセージを送ります．例えば，整数
オブジェクトは(({halt}))メッセージがわかります．(({halt}))メッ
セージは，デバッガを手の中に入れます．

ステップ実行するためには`Step'ボタンを使います．`Step'はスロッ
トアクセス，あるいはスロット代入の結果を返すメッセージをみて
いくだけではなく，他のメソッドの中にまで入っていきます．詳細
を見ずにメッセージ送信の実行を完了させたければ`Next'を使いま
す．

(({withdraw:}))メッセージは以下のようになります．

  * (({halt}))を見ていきます．つまり，保留中の式を強調表示し
    てトップレベルの式が見えるようにします．

  * (({withdraw:}))の中に入っていきます．

  * 引き算と(({max:}))メッセージの詳細を飛ばすために，`Next'
    を使います．

  * 実行を完了するために`Continue'を使うか，計算を中止するた
    めに`Abort'を使います．

== プロトタイプ

Selfはプロトタイプベースの言語です．これは何を意味するのでしょ
うか．

伝統的なオブジェクト指向言語はオブジェクトの構造と振る舞いを
定義するためにクラスを使います．新しいオブジェクトが要求され
たとき，クラスはインスタンス化されなければいけません．オブジェ
クトの構造と振る舞いを変更するということは，クラスが変更され
なければいけないということを意味します．

このアプローチの不利な点は以下の通りです．

  * 新しい種類のオブジェクトを作る前に新しいクラスを作る必要
    があります．オブジェクトの構造，あるいは振る舞いを変えた
    いときは，いつもクラスを変更しなければいけません．すでに
    存在するオブジェクトのクラスを変更できないシステムもあり
    ます．つまり，オブジェクトはクラスが変更された後に再構築
    されなければいけません．クラスを変更したとき，古い振る舞
    いをする要求するインスタンスが存在してはいけません．もし，
    古い振る舞いを要求するインスタンスが存在するのなら，新し
    いサブクラスを作る必要があります．これは，開発を遅らせ，
    実験を妨げます．

  * 新しい種類のオブジェクトを作るとき，普通，求めているオブ
    ジェクトと似たような既に存在しているオブジェクトを探しま
    せん．しかし，求めるものと似ているオブジェクトを定義して
    いるクラスを探します．それから，インスタンスを想像しなけ
    ればいけません．あるいは，もし運がよければ，クラスをイン
    スタンス化してオブジェクトを調べることができます．しかし，
    これはいくらか直感的ではありません．
    
    Slef言語にはクラスがありません．新しいオブジェクトが欲し
    いときは，存在するオブジェクトを探して，それをコピーしま
    す．それから，コピーを変更することができます．これは，他
    のオブジェクトに影響をあたえないので安全です．

=== コピー

動いているプログラムは，普通，たくさんのオブジェクトを作って
います．例えば，点（point），コレクション（collection），グラフィ
カルウィジェット（graphical widget）のようなことです．Selfでは，
これらはすでに存在するオブジェクトと同じような構造と振る舞い
を持っています．そして，これらはコピーすることによって作られ
ます．同じタイプの全てのオブジェクトが（直接的に，あるいは他
のコピー経由で間接的に）コピーされるマスターオブジェクトはプ
ロトタイプとして知られています．

プロトタイプベースの言語でのプログラミングは，望まれる構造と
振る舞いを持つプロトタイプなオブジェクトのコレクションを作る
ことを意味します．つまり，プログラムが走っているとき，新しい
オブジェクトは作成され，望まれる全ての結果を得るために他のオ
ブジェクトと相互に作用します．

それから，各データ型はデータ型のプロトタイプなインスタンスに
よって表現されます．例えば，リストは空リストオブジェクトによっ
て表現されます．もし，新しいリストが欲しいときは，プロトタイ
プなリストをコピーします．

Selfシステムは数百のプロトタイプを持っています．いくつか名前
をあげてみましょう．point, list, sequence, byteVector, set,
dictionary, unixFile, process, profiler, time,
colorPickerMorph, debugger, paint, webBrowser...

=== 継承

これまで検索について説明してきたように，メッセージはレシー
バのどれかのスロットにマッチしなければいけません．もし，マッ
チしなければ，エラーが起こり，デバッガが現れるでしょう．

継承は，他のオブジェクトを探すように拡張し，検索手続きを変更
します．これらの他のオブジェクトは親スロットにいます．親スロッ
トは特別なデータスロットの一つです．どんなデータスロットでも，
スロット名にアスタリスクを付けることによって親を指定できます．

もし，メッセージが親スロットと一緒にオブジェクトに送られたら，
スロットマッチ検索は，もし，そのオブジェクトにスロットが見付
からなかったら親を探すように拡張されます．

もし，検索がメソッドを見付けたら，メッセージのレシーバの文脈
でメソッドは実行されます．つまり，(({self}))はメソッドが見付
かったオブジェクトではなく，メッセージのレシーバに束縛されま
す．

この単純な手段のおかげで，継承はクラスの領域から解放され，全
てのオブジェクトで利用可能になりました．もし，そうしたいなら，
伝統的なクラス-インスタンス関係に似たオブジェクト構造を作る
ことができます．しかし，それを強制しません．

専門用語: 親，子，先祖，子孫という用語を使います．これらの意
味は普段使っている意味と似ています．

=== 銀行口座へのコピーメソッドの追加

銀行口座オブジェクトのコピーを作りましょう．これをするために，
コピーを作るためのメソッドを追加する必要があります．メソッド
は一から書くことができますが，既に存在するメソッドを継承する
方がよいです．

コピーはプロトタイプベースなシステムの基本部分で，それはたく
さん起こります．簡単にコピーを作るために，Selfでは，基本的な
コピー機能を提供する特性（traits）オブジェクトがあります（特
性オブジェクトの詳細はあとで述べます）．これは特性クローン可
能（traits clonable）と呼ばれ，特性オブジェクトから継承して
いるとき，かつそのときに限り，レシーバの単純コピー（クローン）
を作る(({copy}))メソッドを手にすることができます．

それでは，以下のように，スロットに追加することによって，銀行
口座の親として(({traits clonable}))を追加しましょう．

  parent* = traits clonable

銀行口座のタイトルバーで真ん中ボタンで出てくるメニュー（???）
を使ってスロットを追加するところからはじめます．これからは，
このスロットを(({parent*}))と呼びます．名前は重要ではありま
せんが，親スロットを表すために名前の最後にアスタリスクが付い
ていることは重要です．このスロットを定数スロット（等号がこの
事を示しています）として作り，(({traits clonable}))を参照す
るようにします．

緑の承認（accept）ボタンをクリックすると，スロットが追加され
ます．一方，赤いキャンセルボタンをクリックすると行った操作を
キャンセルし，スロットエディタを片付けます．

親スロットのボタンをボタンをクリックすることによって，
(({traits clonable}))を呼び出すことができます．

==== 継承されたメソッドの検索

その先祖が必要なら，そのときに限り，(({traits clonable}))を
見ることによってコピーメソッドの定義を探すことができます．し
かし，一般的には，見付けるべき継承されたメソッドの定義がどこ
にあるか知らないでしょう．手早く検索するために，オブジェクト
のタイトルバーで真ん中ボタンを押してメニューを呼び出し，
`Find slot...'という項目を使うことができます．

これを起動するとエミュレータが現れます．検索したいスロット名
（今回の場合は(({copy}))）を入力し，承認し，展開するボタンを
クリックすることにより検索を開始します．検索は他の活動と同時
に行われます．検索が終了すると，候補のリスト（スロットの継承
された定義の全て）が現れ，それぞれスロットを含んでいるオブジェ
クトを呼び出すボタンが付いています．この場合，一つだけ見付か
ります．よって，オブジェクトが自動的に呼び出されます．

(({copy}))メソッドは自分自身に(({clone}))という名前の一つの
メッセージを送ります．このメッセージを探すために再びエミュレー
タを使うことができます（セレクタをダブルクリックすると編集で
きるようになります）．プリミティブなクローン操作を起動する
(({_CloneIfFail}))という長いメソッドを見付けます．名前が下線
で（アンダースコア）で始まっているので，これはプリミティブで
す．プリミティブについては後で触れます．

==== (({copy}))の起動

これで，評価器の中で(({copy}))という式を評価すれば，銀行口座
をコピー出来ます．

=== クラス無しでプログラムを組織化する

継承をファーストクラスにすることで，いくつかの新しい可能性が
開けてきました．

まず，クラスを作らず，唯一のインスタンスを持つことを強制せず
に，直接独自のオブジェクトを作ることができます．例えば，
Smalltalkでは，(({true}))は(({True}))クラスの唯一のインスタ
ンスです．

次に，自分自身を含めて，どんなオブジェクトでも作ることが出来
ます．まさに，クローンを作ることを意味します（つまり，それ自
身のデータとメソッドのスロットを全て含んでいます）．ふたつの
異なったオブジェクト間で，変数とメソッドを区別する必要はあり
ません．

しかし，再利用可能な部分に分離することを考慮するオブジェクト
を見付けることが出来ます．そのオブジェクトを生成し，一部を共
有することが出来ます．Selfでは，再利用可能な部分を特性オブジェ
クト（traits object）と呼びます．

==== 特性オブジェクト（traits object）

特性オブジェクトは，継承に使われる事を意図した共有可能な状態
と振る舞いだけを持ちます．クラスと違って，子孫内の詳しい記憶
構造を命令しません（???）．それは通常不完全です（例えば，自
分自身に送る全てのメッセージを実装しません．つまり，それらは
子孫で実装されるのです）．適切なメッセージを実装する全てのオ
ブジェクトは特性オブジェクトから継承できます．

特性オブジェクトは複数の子孫を持つとき，本当に便利です．この
とき，全ての子孫の振る舞いを特性オブジェクトの振る舞いを変更
することによって変えることができます．これを証明するためにカ
ウンタを作ってみましょう．

=== 銀行口座の作成

==== なぜつくるのか？

今，ふたつの銀行口座オブジェクトを持っている．もし，
(({deposit:}))メソッドを書き換える決定をし，一方のオブジェク
トの定義を変更してももう一方のオブジェクトに影響はありません．
コピーアンドペーストで新しい定義を他のオブジェクトに広めるこ
とが出来ます．しかし，もしたくさんのコピーが必要であれば，退
屈でミスを起こしやすい作業です．全てのコピー間でメソッドを共
有したいのです．つまり，ひとつの変更が全てのコピーで現れて欲
しいのです．

==== 特性オブジェクトの作成

銀行口座と(({traits clonable}))の間に親オブジェクトを挿入し
ようとしています．これは，銀行口座の特性オブジェクトです．そ
れから，振る舞いを銀行口座からその特性オブジェクトに移動でき
ます．つまり，たくさんの銀行口座を持つとき，特性オブジェクト
を変更することにより全ての銀行口座を変更することが出来ます．

新しい特性オブジェクトは(({traits clonable}))から継承される
ものです．もうすでに(({traits clonable}))を参照する親スロッ
トを持っています．これは，新しいオブジェクトを作るにはよいス
タート地点になります．スロット上で真ん中クリックでメニューを
出して，それを背景にドロップすることによってこのスロットをコ
ピーできます．これは，このスロットを持つ新しいオブジェクトを
作成します．

=== 銀行口座の親スロットの変更

それから，銀行口座の親スロットをこの新しいオブジェクトを参照
するように変更したいです．もし，銀行口座の(({parent}))スロッ
トボタンの上の真ん中ボタンメニューをだすと，`Grab pointer'と
書かれた項目が見えます．この項目を起動するためには，スロット
の外に矢印を書き，手の中に矢印の先頭をおきます．矢印の先頭を
新しいオブジェクトにドロップすることが出来ます．つまり，新し
いオブジェクトが銀行口座の新しいオブジェクトになります．もし
望むなら，同じメニューの`Retract'項目を使うか，矢印のおしり
のところでクリックすることにより矢印を撤回することができます．

==== (({deposit}))，(({withdraw}))メソッドの特性オブジェクトへの移動

最後に，銀行口座から特性オブジェクトへ(({deposit:}))，
(({withdraw:}))スロットを移動します．各スロット上での真ん中
ボタンメニューの`Move'項目を使い，特性オブジェクトのスロット
へドロップします．

=== 作成された銀行口座のテスト

(({deposit:}))，(({withdraw:}))が今でも期待どおりに動くか検
査します．銀行口座のコピーを作り，共有されたこれらのメソッド
の定義を使うテストをすることも出来ます．

デフォルトのコピー操作はローカルオブジェクトしかコピーしない
ことに注意してください．つまり，`浅い'コピーです．コピーは同
じ特性オブジェクトを参照します．

=== 混合した状態と振舞の利点

Selfでは，メソッドスロットとデータスロットを選択したオブジェ
クトに挿入することができます．これは，求めている効果を得るた
めに，よい注意深い設計をする練習ができるようにします．

安全な方法で新しい設計を探検するための柔軟性を使うことも出来
ます．例えば，新しい(({deposit:}))メソッドを試したくなったと
します．しかし，確信がないので，新しいメソッドが動く確信を持
てるまで既存の銀行口座を壊したくありません．

すでに存在している銀行口座をコピーすることによって新しい銀行
口座を作ることができます．そして，その中には(({deposit:}))の
ローカルコピーがあります．他のオブジェクトに影響を与えないと
いう確信の中で(({deposit:}))を実験することが出来ます．新しい
メソッドが動くことを確信したとき，それを特性オブジェクトに移
動します．これで，全ての口座はこれを使うことになります．

=== 取り換え可能な状態と振舞の利点

Selfの別の重要の特長は，メッセージを送ったときに，メッセージ
がメソッドを活性化したか，データスロットにアクセスしたかを区
別しないことです．状態と振舞のあいだの実装を変更することが出
来ます．

例として，株式をベースとした新しい口座の種類を作りましょう．
既存の銀行口座を変更することによりこれを作成します．

最初に，現在の株価と持ち株数を表現するスロットとを追加します．
真ん中ボタンメニューを使ってスロットを追加したら，現在の株価
スロットを使うための構文はこのようになります．

  pricePerShare <- 50.0

口座内の持ち株数を持っているスロットのための構文はこのように
なります．

  numShares <- 10

(({<-}))を使っていることは，スロットは代入可能なデータスロッ
トであり，右辺の値はスロットの初期値を表しています．

残っている(({balance}))スロットは現在は正しくない．つまり，
残高は持ち株数から計算されるべきです．真ん中ボタンメニューの
`Edit'項目を使って，このスロットを編集し，メソッドスロットと
して置き換えることが出来ます．

  balance = (numShares * pricePerShare)

もし，直接残高を設定したい場合は，(({balance:}))というメソッ
ドスロットを追加して，以下のようにすることが出来ます．

  balance: b = (numShares: b / pricePerShare)

=== 株式口座のテスト

これで，残高を求めたり残高を設定することで，株式口座をテスト
できるようになりました．しかし，まだ問題があります．残高を設
定できでしまうのです．つまり，完全でない持ち株数が得られるこ
とがあります．(({balance:}))メソッドを変更しましょう．つまり，
常に整数に端数を切り捨てます．(({balance:}))スロットのボタン
をクリックして，テキストエディタを出します．それからメソッド
本体を変更します．

  numShares: b /- pricePerShare

数上の(({/-}))メソッドは切り捨てられた除算の結果を返します．
(({/-}))は切り上げます．

メソッドのテキストを変更するとすぐに，緑と赤の`事実に反する' 
バーが現れます．Selfでこのバーが出るときは，対応する項目が
`事実に反する'ことを知らせています．すなわち，`真実'に一致し
ていれません．この場合は，エディタ中のテキストがインストール
されているメソッドのソースに対応していません．緑のバーをクリッ
クすることによって本当のものとする（つまり，受理する）か，赤
いバーをクリックしてインストールされているメソッドに戻し，変
更を破棄するかのどちらかを行うことが出来ます．

新しいバージョンを受理したらテストが出来ます．

=== 継承されたメソッドの使用

これから，株式口座から資金の預金と引出しも出来るようにします．

株式口座の親を変更していないので，銀行口座特性から
(({deposit:}))，(({withdraw:}))メソッドを使用しているでしょ
う．

しかし，これらのメソッドは(({balance}))，(({balance:}))メッ
セージがアクセスし，データスロットに設定したときに作られたも
のであることに注目しなさい．子の適切な実装を提供しているので，
これは正しいことです．

=== オブジェクトの名前付け

これまで作った全てのオブジェクトが，単に`an object'とラベル
付けされていたことに気づいているでしょう．一方，(({traits
clonable}))はその通りtraits clonableとラベル付けされています．
Selfでは，オブジェクトはどのように名前を得るのでしょうか？

Selfでは，オブジェクトはパスによって名前を付けられます．パス
はデータスロットの列で，オブジェクトを得るためにパスを辿って
いかなければいけません．パスは(({lobby}))として知られている
特別なオブジェクトから始まります（ほとんどのオブジェクトは最
終的に(({lobby})) から継承されているが，そうしなければいけな
いというわけではありません）．評価器から(({lobby}))を呼び出
すことが出来ます．エキスパンダ（広げるやつ）と名前の間の小さ
いボタンはオブジェクトのコメントがあることを示しています．そ
のボタンをクリックすることでコメントを見ることが出来ます．

そこには(({lobby}))からオブジェクトへのパスがないかもしれま
せんし，複数あるかもしれません．もし，パスがないときは，グロー
バル名を持たないということです．

よく知られたオブジェクトのために，(({lobby}))からオブジェク
トへ少なくともひとつのパスがなければいけません．したがって，
ひとつのパスは他のパスからそのオブジェクトを見分けるためのク
リエイタパスとして設計されなければいけません．これについての
詳細は後で述べますが，今のところは，オブジェクトが名前を持つ
ためにクリエイタパスを設定しなければいけないということで十分
です．

銀行口座と株式口座をインストールしましょう．つまり，これらを
よく知られたものにします．

=== 口座オブジェクトのインストール

銀行口座と株式口座オブジェクトはプロトタイプです．つまり，そ
れらをコピーすることによって新しい口座を作ることが出来ます．
よく知られたプロトタイプを作るための方法は，グローバルネーム
スペースにそれをインストールすることです．

グローバルネームペースは(({lobby}))の(({globals}))スロットに
あるオブジェクトによって実装されている．(({globals}))は親ス
ロットで，(({lobby}))から継承されている全てのオブジェクトも
また(({globals}))にある全てのスロットを継承しています．Self
4.0では，このオブジェクトには313のスロットがあります．

==== カテゴリがまとめるスロット

オブジェクトのスロットをまとめるために，各スロットはカテゴリ
に属することができます．カテゴリはそれ自身カテゴリ化されるこ
とができ，階層を作ることができます．カテゴリ名はどんなもので
も構いません．名前はドキュメント以外の目的を持ちません．新し
いカテゴリは真ん中ボタンメニューの`Add category'項目を使って
追加することができます．カテゴリ名はそれをダブルクリックする
ことにより編集できます．スロットはオブジェクト間を移動するの
と同じ方法でカテゴリ間を移動できます．

=== スロットを(({globals}))へ追加

新しいカテゴリにあるふたつのスロットを(({globals}))に追加し
ましょう．新しいサブカテゴリを作るために，もうすでに存在して
いるカテゴリの上での真ん中ボタンメニューの`Add category'項目
を使います．

それから，カテゴリに新しく(({bankAccount}))と
(({stockAccount}))というふたつのデータスロットを追加します．


スロットを定数にします．はじめは新しい空オブジェクトを参照し
ています．新しい空オブジェクトを作成する構文は空の括弧のペア
です．

  bankAccount = ()

=== オブジェクトへのスロットの接続

スロットを追加するために，スロットと適切なオブジェクト結びつ
ける矢印ドラッグ技法を使うことができます．

=== クリエイタパスの設定

(({lobby}))から各オブジェクトへのパスを持っていますが，それ
をクリエイタパスとして設計していないため名前は変更されていま
せん．

クリエイタパスはパスの中にある各スロット上での真ん中ボタンメ
ニューの`Make creator'項目を使って設定します．設定するために
は，もうすでによく知られたオブジェクトから通じているスロット
上でこれをするだけでよいです．口座オブジェクトでは，これは口
座オブジェクトをよく知られたものとするためにクリエイタとして
(({globals}))のスロットを設定するだけでよいことを意味してい
ます．なぜなら，(({globals}))がもうすでによく知られているか
らです．

最後の変更は，口座オブジェクトの特性のためのクリエイタパスを
設定することです．銀行口座の親スロットをクリエイタとするか，
株式口座の親スロットをクリエイタとするか，どちらでもよいです．
どちらを選んかは重要ではありません．

これで，(({bankAccount}))か(({stockAccount}))のコピーを作れ
ば，コピーは`a bankAccount'か`a stockAccount'とラベル付けさ
れます．

== 変更の終了: プライバシとコメント

(({lobby}))あるいは(({globals}))のスロットの名前はさまざまな
フォントで表示されていることに気付いたでしょう．これは，意図
された使用方法を反映しています．

Selfオブジェクトのすべてのスロットはpublic，privateあるいは
undeclared（宣言無し）として宣言することができます．デフォル
トはundeclaredで，これらのスロット名はsnas-serif（飾り無し）
フォントになります．publicスロットは太字のserif（飾り付き）
フォントで，privateスロットは細いserifフォントになります．

カテゴリは名前でアルファベット順に並び替えられます．カテゴリ
の中では，親スロットが他のスロットより前に現れ，publicスロッ
トはundeclaredスロットより前に現れます．privateスロットは
undeclaredスロットの後に現れます．

publicとprivateの区別は純粋にドキュメントです．Selfの初期の
バージョンでは，プライバシ（privateスロットを見付けるために
自分自身にだけメッセージを送ることが許される）を主張していま
したが，この方法はうまく機能しないことがわかりました．

グローバルネームスペースに口座をインストールしたので，スロッ
トをpublicと指定すべきです．

=== コメント

コメントを追加するべきです．コメントを入れる場所は3つありま
す．メソッド中，スロット，オブジェクトです．

コメントを使うためのガイドラインは以下の通りです．

  * もし，コメントがメソッドの実装に関するものであればメソッ
    ド中にコメントを入れます．コメントはダブルクォートで囲ま
    れます．

  * もし，コメントをスロットの目的に適用するなら，スロットに
    コメントを入れます．スロットメニューから真ん中ボタンメ
    ニューの`Show comment'項目を使います．

  * もし，コメントをオブジェクトの目的に適用するなら，スロッ
    トにコメントを入れます．オブジェクトのヘッダから真ん中ボ
    タンメニューの`Show comment'項目を使います．

もし，スロット，あるいはオブジェクトがコメントを持っている場
合は，（引用マーク付きの）小さなボタンが左に現れます．コメン
トを展開するためにそのボタンをクリックしてください．これで，
コメントを直接編集できます．

スロットをpublicに宣言したとき，コメントの入力を求められます．

オブジェクトをコピーしたとき，コメントもコピーされるので，プ
ロトタイプだけに該当するコメントを作ってはいけません．

=== もっとネームスペース

(({lobby}))は実はふたつの親を持っています．もうひとつの親ス
ロットは(({defaultBehavior}))と呼ばれていて，全てのオブジェ
クトに適用可能なメソッド（同一テスト，(({==}))や
(({printString}))，(({error:}))，(({halt}))のデフォルトの実
装など）をもっています．

したがって，(({lobby}))から継承されている全てのオブジェクト
は(({defaultBehavior}))で定義されているメッセージに対して反
応することができ，(({globals}))経由でプロトタイプにアクセス
することができます．

(({globals}))から(({defaultBehavior}))を分離することにより，
もし適しているなら，どちらか一方だけを継承することを許します．

==== 他のネームスペース

(({lobby}))は親スロットではないスロットからアクセス可能なふ
たつの追加可能なネームスペースをもっています．

  (1) (({traits}))ネームスペース．これは他の特性のコレクショ
      ンを含んでいます．

  (1) (({mixins}))ネームスペース．これは(({mixins}))として使
      われるための特性のようなオブジェクトを含んでいます．つ
      まり，こども達は主な機能を提供している他の親を持ってい
      ます．

これらのネームスペースの使用を徐々に減らしています．新しいア
プリケーションはこれらのネームスペースに追加するべきではあり
ませんが，局所的にそのままになっています．例えば，
(({webBrowser}))，(({transporter}))，(({smalltalkEmulator})) 
です．これは，これらの領域で潜在的な名前衝突を避けています．

=== 現実的な問題

いくつかの現実的な問題は構文エラーとデバッガです．

もし，ミスを犯したら，ふたつの似たような結果があります．

ひとつめは構文的に不正なSelf式の入力したときです．これは，赤
いエラー通知者を登場させます．エラーは少ししたらスクリーンか
ら消えるでしょう．

ふたつめは構文的に妥当な式を入力しましたが，実行時エラーを引
き起こすときです．例えば，不適切なメッセージを送ったようなと
きです．これはデバッガを登場させます（これは緑で，子どものよ
うに友好的に見せようとしています）．混乱しないでください．

いくつかのオプションがあります．ひとつはデバッガのメッセージ
を読むためのもので，それからメッセージを隠すか，デバッグを終
了します．別のものはスタックエキスパンダを使ってプロセスのス
タックを調べるためのものです．各スタックフレームにおいてメソッ
ドエディタを開くことによって失敗時に何が起こったのかを監視す
ることができます．そして，もし望むなら問題を修正することさえ
できます．

=== より現実的な問題

Selfで作業するとき，新しいオブジェクトを作ったり，既にあるオ
ブジェクトを変更するでしょう．どんなときでも，スナップショッ
トファイルにシステムの全てのオブジェクトの現在の状態を保存す
ることができます．それには，背景の真ん中ボタン（黄色）メニュー
の`Save snapshot'か`Save snapshot as...'を使います．

`Save snapshot'はデフォルトの名前のファイルに書き出します．
デフォルトの名前は普通起動時に使った名前と同じ名前です．スナッ
プショットを保存するとき，既に存在するスナップショットを上書
きしません．つまり，古いスナップショットを.backupという拡張
子を付けてリネームします（これにより前のバックアップは失われ
るかもしれません）．

`Save snapshot as...'はダイアログでユーザの注意を引きます．
ダイアログはユーザがデフォルトのスナップショット名を変更する
のを許し，いくつかのスナップショットに関連したオプションを設
定します．これらの説明はダイアログ中にあります．つまり，ここ
では解説しません．

`Quit...'メニュー項目を使えばシステムを終了することができま
す．これは，終了する前にスナップショットを保存するか，すぐに
終了するか，システムを続行するかを聞いてきます．

スナップショットを再起動するとき，Selfシステム（ユーザインター
フェイスも含む）はスナップショットが作られたときと同じ状態に
復元されます（例外: リリース4.0はスナップショットにプロセス
の状態を保存しません．つまり，走っているプロセスはスナップ
ショットが復元されたときに再起動しなければいけません．（ユー
ザインターフェイスのような）システムプロセスに対しては，これ
は自動的に行われます．たとえデバッグ中であっても，中断したプ
ロセスの状態は不幸にも失われてしまいます）．

特に，リスクの高い変更をはじめる前は．作業中に定期的にスナッ
プショットをとるのはよい考えです．

もし，複数のスナップショットを保存したいが，ディスク容量が高
価なら，スナップショットダイアログにある圧縮とコード保存オプ
ションについて調べるべきです．

== 要約

  * オブジェクトはメソッドスロットと定数／代入可能データスロッ
    トから作られます．データスロットは親になることができます．

  * 全てはメッセージによって開始されます．つまり，スロットア
    クセス，スロット代入，メソッド起動です．

  * システムはプロトタイプの周囲に構成され，プロトタイプはコ
    ピーされます．

  * 共有される振舞は継承から得られます．つまり，特性オブジェ
    クトが共有されるふるまいをもっています．

  * ネームスペースはオブジェクトでできています．

== Selfの構文と意味

=== 序文

さぁ，言語の詳細をもっとみてみましょう．

=== リテラル

Selfには3つの単純なリテラルがあります．

  * 整数（10進数でないものは10進数で表現された基数とrを前に
    書きます．例えば，16rFFや2r101010となります．）

  * 浮動小数点数（すべてのよくある記法）

  * 文字列（Cのようなエスケープシーケンスの埋め込みも含む）
    はシングルクォートで囲みます．

      'a string'
      'an embedded \' quote'
      ''   "空文字列"
      'lots\tof\nstrange\r\\characters\0'

コメントはダブルクォートで囲みます．

  "this is a comment"

(({self}))と(({resend}))だけが予約識別子です．

識別子は文字，数字，アンダースコアを含むことができ，小文字で
はじめなければいけません．大文字小文字には意味があります．

=== メッセージ

メッセージにはいくつの引数が渡されたかによって3つの構文があ
ります（構文はSmalltalkに非常に似ています）．

単項メッセージは引数がなく，レシーバを意味する式の後に識別子
をひとつ書きます．例えば以下のとおりです．

  3.14 sin        "3.14にsinを送る"
  account balance "アカウントにbalanceを送る"

キーワードメッセージはひとつ以上のキーワードを含みます．それ
ぞれのキーワードには引数を意味する式が続きます．各キーワード
は識別子があり，すぐそのあとにコロンが続きます．キーワードメッ
セージの最初のキーワードは小文字ではじめなければいけません．
つまり，連続するキーワードは大文字ではじめなければいけません．
例です．

  account deposit: 100 "accountに引数として100とともにdeposit:を送る"
  vec at: 2 Put: 'c'   "vecに引数として2と'c'とともにat:Put:を送る"

二項メッセージはひとつの引数を渡すために使われます．このメッ
セージは（いくつかの特別な文字をのぞく）1つ以上のアルファベッ
ト／数字以外の文字から作られるシンボルからなります．このシン
ボルはレシーバと引数の間に現れます．例です．

  3 + 4       "3に引数として4とともに+を送る"
  23.1 @ 40.4 "23.1に引数として40.4とともに@を送る"

これらが組み合わされたとき，優先順位は単項，二項，キーワード
メッセージとなります．単項と，二項メッセージは左から右に結合
し，キーワードメッセージは右から左に結合します．全ての二項メッ
セージは同じ優先度をもっていますが，メッセージが同じかメッセー
ジを結合するために括弧を使わない限り，二項メッセージの結果に
式を送ることはできません．

括弧付きの同等なものとともに例をあげます．

  x + y squared                 x + (y squared)
  sq at: n + 1 Put: n squared   sq at: (n + 1) Put: (n squared)
  x + y + z                     (x + y) + z
  a max: b min: c               a max: (b min: c)

==== 練習問題

以下の式の値は何になるか？

  1 + 2 * 3 + 4
  1 max: 4 + 3 negated min: 0

=== リテラルオブジェクト

Other objects can
